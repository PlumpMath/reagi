<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>reagi.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Reagi 0.7.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="reagi.core.html"><span>reagi.core</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="reagi.core.html#var-accum"><span>accum</span></a></li><li><a href="reagi.core.html#var-behavior"><span>behavior</span></a></li><li><a href="reagi.core.html#var-behavior-call"><span>behavior-call</span></a></li><li><a href="reagi.core.html#var-behavior%3F"><span>behavior?</span></a></li><li><a href="reagi.core.html#var-cons"><span>cons</span></a></li><li><a href="reagi.core.html#var-constantly"><span>constantly</span></a></li><li><a href="reagi.core.html#var-count"><span>count</span></a></li><li><a href="reagi.core.html#var-cycle"><span>cycle</span></a></li><li><a href="reagi.core.html#var-delay"><span>delay</span></a></li><li><a href="reagi.core.html#var-delta"><span>delta</span></a></li><li><a href="reagi.core.html#var-ensure"><span>ensure</span></a></li><li><a href="reagi.core.html#var-events"><span>events</span></a></li><li><a href="reagi.core.html#var-events%3F"><span>events?</span></a></li><li><a href="reagi.core.html#var-evt"><span>evt</span></a></li><li><a href="reagi.core.html#var-filter"><span>filter</span></a></li><li><a href="reagi.core.html#var-map"><span>map</span></a></li><li><a href="reagi.core.html#var-mapcat"><span>mapcat</span></a></li><li><a href="reagi.core.html#var-merge"><span>merge</span></a></li><li><a href="reagi.core.html#var-push%21"><span>push!</span></a></li><li><a href="reagi.core.html#var-reduce"><span>reduce</span></a></li><li><a href="reagi.core.html#var-remove"><span>remove</span></a></li><li><a href="reagi.core.html#var-sample"><span>sample</span></a></li><li><a href="reagi.core.html#var-sub"><span>sub</span></a></li><li><a href="reagi.core.html#var-tap"><span>tap</span></a></li><li><a href="reagi.core.html#var-throttle"><span>throttle</span></a></li><li><a href="reagi.core.html#var-time"><span>time</span></a></li><li><a href="reagi.core.html#var-uniq"><span>uniq</span></a></li><li><a href="reagi.core.html#var-unsub"><span>unsub</span></a></li><li><a href="reagi.core.html#var-zip"><span>zip</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>reagi.core documentation</h2><pre class="doc"></pre><div class="public" id="var-accum"><h3>accum</h3><div class="usage"><code>(accum init stream)</code></div><pre class="doc">Change an initial value based on an event stream of functions.
</pre></div><div class="public" id="var-behavior"><h3>behavior</h3><h4 class="macro">macro</h4><div class="usage"><code>(behavior &amp; form)</code></div><pre class="doc">Takes a body of expressions and yields a behavior object that will evaluate
the body each time it is dereferenced.</pre></div><div class="public" id="var-behavior-call"><h3>behavior-call</h3><div class="usage"><code>(behavior-call func)</code></div><pre class="doc">Takes a zero-argument function and yields a Behavior object that will
evaluate the function each time it is dereferenced. See: behavior.</pre></div><div class="public" id="var-behavior%3F"><h3>behavior?</h3><div class="usage"><code>(behavior? x)</code></div><pre class="doc">Return true if the object is a behavior.
</pre></div><div class="public" id="var-cons"><h3>cons</h3><div class="usage"><code>(cons value stream)</code></div><pre class="doc">Return a new event stream with an additional value added to the beginning.
</pre></div><div class="public" id="var-constantly"><h3>constantly</h3><div class="usage"><code>(constantly value stream)</code></div><pre class="doc">Constantly map the same value over an event stream.
</pre></div><div class="public" id="var-count"><h3>count</h3><div class="usage"><code>(count stream)</code></div><pre class="doc">Return an accumulating count of the items in a stream.
</pre></div><div class="public" id="var-cycle"><h3>cycle</h3><div class="usage"><code>(cycle values stream)</code></div><pre class="doc">Incoming events cycle a sequence of values. Useful for switching between
states.</pre></div><div class="public" id="var-delay"><h3>delay</h3><div class="usage"><code>(delay delay-ms stream)</code></div><pre class="doc">Delay all events by the specified number of milliseconds.
</pre></div><div class="public" id="var-delta"><h3>delta</h3><div class="usage"><code>(delta)</code></div><pre class="doc">Return a behavior that tracks the time in seconds from when it was created.
</pre></div><div class="public" id="var-ensure"><h3>ensure</h3><div class="usage"><code>(ensure stream)</code></div><pre class="doc">Block until the first value of the stream becomes available, then return the
stream.</pre></div><div class="public" id="var-events"><h3>events</h3><div class="usage"><code>(events)</code><code>(events ch)</code><code>(events ch closed?)</code><code>(events ch closed? clean-up)</code><code>(events ch closed? clean-up deps)</code></div><pre class="doc">Create an referential stream of events. The stream may be instantiated from
an existing core.async channel, otherwise a new one will be created. If the
stream is closed, it cannot be pushed to.

A clean-up function may optionally be specified, which is evaluated when the
stream object is finalized (i.e. GCed). A list of dependent streams may also
be included, in order to protect them against premature GC.

If you're not deriving the event stream from an existing channel or another
stream, use the no-argument form.</pre></div><div class="public" id="var-events%3F"><h3>events?</h3><div class="usage"><code>(events? x)</code></div><pre class="doc">Return true if the object is a stream of events.
</pre></div><div class="public" id="var-evt"><h3>evt</h3><div class="usage"><code>(evt msg)</code></div><pre class="doc">Create an event suitable to be pushed onto a channel.
</pre></div><div class="public" id="var-filter"><h3>filter</h3><div class="usage"><code>(filter pred stream)</code></div><pre class="doc">Filter a stream by a predicate.
</pre></div><div class="public" id="var-map"><h3>map</h3><div class="usage"><code>(map f &amp; streams)</code></div><pre class="doc">Map a function over a stream.
</pre></div><div class="public" id="var-mapcat"><h3>mapcat</h3><div class="usage"><code>(mapcat f stream)</code><code>(mapcat f stream &amp; streams)</code></div><pre class="doc">Mapcat a function over a stream.
</pre></div><div class="public" id="var-merge"><h3>merge</h3><div class="usage"><code>(merge &amp; streams)</code></div><pre class="doc">Combine multiple streams into one. All events from the input streams are
pushed to the returned stream.</pre></div><div class="public" id="var-push%21"><h3>push!</h3><div class="usage"><code>(push! stream)</code><code>(push! stream msg)</code><code>(push! stream msg &amp; msgs)</code></div><pre class="doc">Push one or more messages onto the stream.
</pre></div><div class="public" id="var-reduce"><h3>reduce</h3><div class="usage"><code>(reduce f stream)</code><code>(reduce f init stream)</code></div><pre class="doc">Create a new stream by applying a function to the previous return value and
the current value of the source stream.</pre></div><div class="public" id="var-remove"><h3>remove</h3><div class="usage"><code>(remove pred stream)</code></div><pre class="doc">Remove all items in a stream the predicate does not match.
</pre></div><div class="public" id="var-sample"><h3>sample</h3><div class="usage"><code>(sample interval-ms reference)</code></div><pre class="doc">Turn a reference into an event stream by deref-ing it at fixed intervals.
The interval time is specified in milliseconds.</pre></div><div class="public" id="var-sub"><h3>sub</h3><div class="usage"><code>(sub stream channel)</code></div><pre class="doc">Tell the stream to send events to an existing core.async channel.
</pre></div><div class="public" id="var-tap"><h3>tap</h3><div class="usage"><code>(tap stream)</code></div><pre class="doc">Create a core.async channel that receives events from the supplied event
stream.</pre></div><div class="public" id="var-throttle"><h3>throttle</h3><div class="usage"><code>(throttle timeout-ms stream)</code></div><pre class="doc">Remove any events in a stream that occur too soon after the prior event.
The timeout is specified in milliseconds.</pre></div><div class="public" id="var-time"><h3>time</h3><div class="usage"></div><pre class="doc">A behavior that tracks the current time in seconds.
</pre></div><div class="public" id="var-uniq"><h3>uniq</h3><div class="usage"><code>(uniq stream)</code></div><pre class="doc">Remove any successive duplicates from the stream.
</pre></div><div class="public" id="var-unsub"><h3>unsub</h3><div class="usage"><code>(unsub stream channel)</code></div><pre class="doc">Tell the stream to stop sending events the the supplied channel.
</pre></div><div class="public" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip &amp; streams)</code></div><pre class="doc">Combine multiple streams into one. On an event from any input stream, a
vector will be pushed to the returned stream containing the latest events
of all input streams.</pre></div></div></body></html>